<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>åŒ»ç–—åŠ©æ‰‹ â€” è½¬å†™ & ç—…å†æ€»ç»“ æµ‹è¯•é¡µ</title>
  <style>
    body { font-family: -apple-system,BlinkMacSystemFont,'Segoe UI',Roboto,'Helvetica Neue',Arial; background:#f5f7fb; padding:24px; color:#222 }
    .card{background:#fff;border-radius:8px;padding:18px;box-shadow:0 6px 18px rgba(0,0,0,.06);max-width:900px;margin:0 auto}
    h1{font-size:18px;margin:0 0 12px}
    .row{display:flex;gap:12px;align-items:center;margin-bottom:12px}
    label{min-width:100px;color:#555}
    input[type=text],select,input[type=number]{padding:6px 8px;border:1px solid #dcdfe6;border-radius:6px;width:240px}
    button{padding:8px 12px;border-radius:6px;border:0;background:#3b82f6;color:#fff;cursor:pointer}
    button.secondary{background:#6b7280}
    pre{background:#0f172a;color:#e6eef8;padding:12px;border-radius:6px;overflow:auto}
    .log{height:160px;overflow:auto;border:1px solid #e6e9ef;padding:8px;border-radius:6px;background:#fff}
    small.hint{color:#6b7280}
  </style>
</head>
<body>
  <div class="card">
    <h1>æµ‹è¯•ç•Œé¢ â€” è¯­éŸ³è½¬å†™ & ç—…å†æ€»ç»“</h1>
    <div class="row">
      <label>ç”¨æˆ·ID</label>
      <input id="userId" type="text" value="test_user_001">
      <label style="min-width:70px">visitId</label>
      <input id="visitId" type="text" value="visit1">
      <label style="min-width:60px">doctorId</label>
      <input id="doctorId" type="text" value="doc1">
    </div>

    <hr>

    <h3>å•æ–‡ä»¶ä¸Šä¼ ï¼ˆ/api/transcription/uploadï¼‰</h3>
    <div class="row">
      <label>é€‰æ‹©éŸ³é¢‘</label>
      <input id="fileInput" type="file" accept="audio/*">
      <button id="uploadBtn">ä¸Šä¼ å¹¶è½¬å†™</button>
      <small class="hint">æ”¯æŒ .wav/.pcm ç­‰ï¼ˆå¦‚æœä¸º wavï¼Œè¯·ç¡®ä¿é‡‡æ ·ç‡ä¸º 16000ï¼‰</small>
    </div>

    <h3>æµå¼è½¬å†™ï¼ˆåˆ†å—å‘é€ï¼‰</h3>
    <div class="row">
      <label>å¸§å¤§å°(bytes)</label>
      <input id="frameSize" type="number" value="1280">
      <label>å¸§é—´éš”(ms)</label>
      <input id="frameInterval" type="number" value="40">
    </div>
    <div class="row">
      <button id="startStreamBtn">å¯åŠ¨ä¼šè¯</button>
      <button id="sendStreamBtn" class="secondary">åˆ†å—å‘é€é€‰ä¸­æ–‡ä»¶</button>
      <button id="endStreamBtn" class="secondary">ç»“æŸä¼šè¯</button>
      <div id="sessionLabel" style="margin-left:8px;color:#374151"></div>
    </div>

    <hr>
    <h3>ç—…å†æ€»ç»“ï¼ˆSSE /api/medical-summary/generate/{visitId}ï¼‰</h3>
    <div class="row">
      <button id="startSummaryBtn">å¼€å§‹è®¢é˜…ç—…å†ç”Ÿæˆ</button>
      <button id="stopSummaryBtn" class="secondary">åœæ­¢</button>
      <small class="hint">éœ€è¦åç«¯å·²æœ‰ visitId çš„è½¬å½•æ–‡æœ¬ï¼Œå¦åˆ™ä¼šè¿”å›é”™è¯¯</small>
    </div>

    <hr>
    <h3>ç»“æœ / æ—¥å¿—</h3>
    <div style="display:flex;gap:12px">
      <div style="flex:1">
        <div style="margin-bottom:8px"><strong>è½¬å†™ç»“æœ</strong></div>
        <pre id="transcriptionOutput">(æ— )</pre>
      </div>
      <div style="width:420px">
        <div style="margin-bottom:8px"><strong>SSE ç—…å†äº‹ä»¶</strong></div>
        <div id="summaryOutput" class="log">(æœªè®¢é˜…)</div>
      </div>
    </div>

    <hr>
    <div style="margin-top:12px"><strong>ç½‘ç»œ / æ§åˆ¶å°æ—¥å¿—</strong></div>
    <div id="console" class="log"></div>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    const consoleLog = (s)=>{ const el=$('console'); el.textContent = new Date().toLocaleTimeString() + ' ' + s + '\n' + el.textContent }

    // Upload single file
    $('uploadBtn').addEventListener('click', async ()=>{
      const file = $('fileInput').files[0];
      if(!file){ alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶'); return }
      const fd = new FormData();
      fd.append('file', file, file.name);
      fd.append('userId', $('userId').value);
      fd.append('audioEncode', 'pcm_s16le');
      fd.append('sampleRate', '16000');
      fd.append('lang', 'autodialect');
      fd.append('visitId', $('visitId').value);
      consoleLog('POST /api/transcription/upload æ–‡ä»¶ ' + file.name);
      try{
        const res = await fetch('/api/transcription/upload', {method:'POST', body:fd});
        const json = await res.json();
        if(!res.ok){ consoleLog('ä¸Šä¼ è¿”å›é”™è¯¯: ' + JSON.stringify(json)); alert('ä¸Šä¼ å¤±è´¥: '+ (json.message || JSON.stringify(json))); return }
        consoleLog('ä¸Šä¼ æˆåŠŸï¼Œå“åº”ï¼š' + JSON.stringify(json));
        $('transcriptionOutput').textContent = json.transcriptionText || JSON.stringify(json, null, 2);
      }catch(e){ consoleLog('ä¸Šä¼ å¼‚å¸¸ ' + e.message); alert('ä¸Šä¼ å¼‚å¸¸: '+e.message) }
    })

    // Stream control
    let currentSession = null;
    $('startStreamBtn').addEventListener('click', async ()=>{
      const body = { userId: $('userId').value, audioEncode:'pcm_s16le', sampleRate:16000, visitId: $('visitId').value };
      consoleLog('POST /api/transcription/stream/start ' + JSON.stringify(body));
      try{
        const res = await fetch('/api/transcription/stream/start', {method:'POST', headers:{'Content-Type':'application/json'}, body: JSON.stringify(body)});
        const json = await res.json();
        if(!res.ok){ consoleLog('start error ' + JSON.stringify(json)); alert('å¯åŠ¨å¤±è´¥: '+JSON.stringify(json)); return }
        currentSession = json.sessionId;
        $('sessionLabel').textContent = 'sessionId: ' + currentSession;
        consoleLog('Stream started: ' + currentSession);
      }catch(e){ consoleLog('start exception '+e.message); alert('å¯åŠ¨å¼‚å¸¸: '+e.message) }
    })

    $('sendStreamBtn').addEventListener('click', async ()=>{
      if(!currentSession){ alert('è¯·å…ˆå¯åŠ¨ä¼šè¯'); return }
      const file = $('fileInput').files[0]; if(!file){ alert('è¯·é€‰æ‹©è¦å‘é€çš„éŸ³é¢‘æ–‡ä»¶'); return }
      const frameSize = parseInt($('frameSize').value || '1280');
      const frameInterval = parseInt($('frameInterval').value || '40');
      consoleLog('å¼€å§‹åˆ†å—å‘é€ï¼š' + file.name + ' frame=' + frameSize + 'ms=' + frameInterval);

      const ab = await file.arrayBuffer();
      for(let offset=0; offset<ab.byteLength; offset += frameSize){
        const end = Math.min(ab.byteLength, offset + frameSize);
        const chunk = ab.slice(offset, end);
        try{
          await fetch(`/api/transcription/stream/send/${encodeURIComponent(currentSession)}`, {method:'POST', headers:{'Content-Type':'application/octet-stream'}, body: chunk});
        }catch(e){ consoleLog('å‘é€é”™è¯¯: ' + e.message); break }
        await new Promise(r => setTimeout(r, frameInterval));
      }
      consoleLog('åˆ†å—å‘é€å®Œæˆ');
    })

    $('endStreamBtn').addEventListener('click', async ()=>{
      if(!currentSession){ alert('æ²¡æœ‰æ´»åŠ¨ä¼šè¯'); return }
      consoleLog('POST /api/transcription/stream/end/' + currentSession);
      try{
        const res = await fetch(`/api/transcription/stream/end/${encodeURIComponent(currentSession)}`, {method:'POST'});
        const json = await res.json();
        consoleLog('ç»“æŸä¼šè¯å“åº”: ' + JSON.stringify(json));
        $('transcriptionOutput').textContent = json.transcriptionText || JSON.stringify(json, null, 2);
        currentSession = null; $('sessionLabel').textContent='';
      }catch(e){ consoleLog('end exception ' + e.message); alert('ç»“æŸå¼‚å¸¸: '+e.message) }
    })

    // SSE - medical summary
    let summaryEventSource = null;
    $('startSummaryBtn').addEventListener('click', ()=>{
      const visitId = encodeURIComponent($('visitId').value);
      const doctorId = encodeURIComponent($('doctorId').value);
      if(!visitId){ alert('è¯·è¾“å…¥ visitId'); return }
      const url = `/api/medical-summary/generate/${visitId}?doctorId=${doctorId}&patientId=test_patient`;
      consoleLog('æ‰“å¼€SSE: ' + url);
      $('summaryOutput').textContent = '(è®¢é˜…ä¸­...)';
      summaryEventSource = new EventSource(url, {withCredentials:false});
      summaryEventSource.onmessage = (ev) => {
        // SSE æœåŠ¡ç«¯ä¼šå‘é€ data: {"event":"message","content":"..."}
        try{
          const dataStr = ev.data;
          $('summaryOutput').textContent = dataStr + '\n' + $('summaryOutput').textContent;
        }catch(e){ consoleLog('SSE parse error '+e.message) }
      };
      summaryEventSource.onerror = (err) => { consoleLog('SSE é”™è¯¯æˆ–å·²æ–­å¼€'); summaryEventSource.close(); summaryEventSource=null }
    })
    $('stopSummaryBtn').addEventListener('click', ()=>{ if(summaryEventSource){ summaryEventSource.close(); summaryEventSource=null; $('summaryOutput').textContent='(æœªè®¢é˜…)'; consoleLog('SSE å·²å…³é—­') }})

  </script>
</body>
</html>
      .settings-row {
        flex-direction: column;
      }

      .setting-item {
        min-width: 100%;
      }
    }
  </style>
</head>
<body>
<div class="container">
  <h1>ğŸ¥ æ™ºèƒ½åŒ»ç–—åŠ©æ‰‹</h1>
  <p class="subtitle">è¯­éŸ³è½¬å½•æµ‹è¯•ç³»ç»Ÿ</p>

  <!-- é”™è¯¯æç¤º -->
  <div id="errorMessage" class="error-message"></div>

  <!-- è®¾ç½®é¢æ¿ -->
  <div class="settings-panel">
    <div class="settings-row">
      <div class="setting-item">
        <label for="userId">ç”¨æˆ·ID</label>
        <input type="text" id="userId" placeholder="è¯·è¾“å…¥ç”¨æˆ·ID" value="test_user_001">
      </div>
      <div class="setting-item">
        <label for="language">è¯­è¨€æ¨¡å¼</label>
        <select id="language">
          <option value="autodialect">ä¸­è‹±+æ–¹è¨€è¯†åˆ«</option>
          <option value="autominor">37è¯­ç§è¯†åˆ«</option>
        </select>
      </div>
      <div class="setting-item">
        <label for="domain">é¢†åŸŸä¼˜åŒ–</label>
        <select id="domain">
          <option value="">æ— </option>
          <option value="medical" selected>åŒ»ç–—</option>
          <option value="finance">é‡‘è</option>
          <option value="court">æ³•å¾‹</option>
          <option value="edu">æ•™è‚²</option>
        </select>
      </div>
    </div>
  </div>

  <!-- æ§åˆ¶é¢æ¿ -->
  <div class="control-panel">
    <button id="recordButton" class="record-button">
      <span class="icon">ğŸ¤</span>
      <span class="text">å¼€å§‹å½•éŸ³</span>
    </button>

    <div class="status-bar">
      <div id="statusIndicator" class="status-indicator ready"></div>
      <span id="statusText" class="status-text">å‡†å¤‡å°±ç»ª</span>
      <span id="timer" class="timer">00:00</span>
    </div>

    <!-- éŸ³é¢‘å¯è§†åŒ– -->
    <div id="audioVisualizer" class="audio-visualizer" style="display: none;">
      <!-- åŠ¨æ€ç”ŸæˆéŸ³é¢‘æ¡ -->
    </div>
  </div>

  <!-- ç»“æœé¢æ¿ -->
  <div class="result-panel">
    <div class="result-header">
      <span class="result-title">è½¬å½•ç»“æœ</span>
      <button id="copyButton" class="copy-button">ğŸ“‹ å¤åˆ¶</button>
    </div>
    <div id="resultContent" class="result-content empty">
      ç‚¹å‡»"å¼€å§‹å½•éŸ³"æŒ‰é’®å¼€å§‹è¯­éŸ³è½¬å½•...
    </div>
  </div>

  <!-- å†å²è®°å½•é¢æ¿ -->
  <div class="history-panel">
    <div class="history-title">ğŸ“ å†å²è®°å½•</div>
    <div id="historyList" class="history-list">
      <!-- åŠ¨æ€ç”Ÿæˆå†å²è®°å½• -->
    </div>
  </div>
</div>

<!-- å…³é”®ä¿®æ”¹ï¼šå°†JSä»£ç ç§»åˆ°HTMLç»“æ„åé¢ï¼Œç¡®ä¿DOMå…ƒç´ å…ˆåŠ è½½ -->
<script>
  // å…¨å±€å˜é‡
  let isRecording = false;
  let mediaRecorder = null;
  let audioChunks = [];
  let startTime = null;
  let timerInterval = null;
  let sessionId = null;
  let audioContext = null;
  let analyser = null;
  let visualizerInterval = null;
  let audioProcessor = null;

  // DOM å…ƒç´  - åœ¨é¡µé¢åŠ è½½åæ‰è·å–
  let recordButton, statusIndicator, statusText, timer, resultContent, copyButton, historyList, errorMessage, audioVisualizer;

  // åˆå§‹åŒ– - ç¡®ä¿DOMå®Œå…¨åŠ è½½åå†æ‰§è¡Œ
  document.addEventListener('DOMContentLoaded', () => {
    console.log('é¡µé¢åŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');

    // è·å–DOMå…ƒç´  - åªæœ‰åœ¨DOMå®Œå…¨åŠ è½½åæ‰èƒ½è·å–åˆ°
    recordButton = document.getElementById('recordButton');
    statusIndicator = document.getElementById('statusIndicator');
    statusText = document.getElementById('statusText');
    timer = document.getElementById('timer');
    resultContent = document.getElementById('resultContent');
    copyButton = document.getElementById('copyButton');
    historyList = document.getElementById('historyList');
    errorMessage = document.getElementById('errorMessage');
    audioVisualizer = document.getElementById('audioVisualizer');

    // æ£€æŸ¥æ‰€æœ‰å¿…éœ€çš„å…ƒç´ æ˜¯å¦å­˜åœ¨
    if (!recordButton) {
      console.error('é”™è¯¯ï¼šæœªæ‰¾åˆ°recordButtonå…ƒç´ ');
      showError('é¡µé¢é…ç½®é”™è¯¯ï¼šæœªæ‰¾åˆ°å½•éŸ³æŒ‰é’®');
      return;
    }

    if (!audioVisualizer) {
      console.error('è­¦å‘Šï¼šæœªæ‰¾åˆ°audioVisualizerå…ƒç´ ');
    }

    if (!resultContent) {
      console.error('é”™è¯¯ï¼šæœªæ‰¾åˆ°resultContentå…ƒç´ ');
      showError('é¡µé¢é…ç½®é”™è¯¯ï¼šæœªæ‰¾åˆ°ç»“æœæ˜¾ç¤ºåŒºåŸŸ');
      return;
    }

    console.log('æ‰€æœ‰DOMå…ƒç´ è·å–æˆåŠŸ');

    // åˆå§‹åŒ–å„ç»„ä»¶
    initAudioVisualizer();
    loadHistory();
    checkMicrophonePermission();
    setupEventListeners();
  });

  // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
  function setupEventListeners() {
    // å½•éŸ³æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    recordButton.addEventListener('click', async () => {
      if (!isRecording) {
        await startRecording();
      } else {
        await stopRecording();
      }
    });

    // å¤åˆ¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
    copyButton.addEventListener('click', () => {
      const text = resultContent.textContent;
      if (text && !resultContent.classList.contains('empty')) {
        navigator.clipboard.writeText(text).then(() => {
          copyButton.textContent = 'âœ… å·²å¤åˆ¶';
          setTimeout(() => {
            copyButton.textContent = 'ğŸ“‹ å¤åˆ¶';
          }, 2000);
        }).catch(err => {
          showError('å¤åˆ¶å¤±è´¥: ' + err.message);
        });
      }
    });

    // é”®ç›˜å¿«æ·é”®
    document.addEventListener('keydown', (e) => {
      if (e.code === 'Space' && e.target.tagName !== 'INPUT' && e.target.tagName !== 'SELECT') {
        e.preventDefault();
        recordButton.click();
      }
    });
  }

  // æ£€æŸ¥éº¦å…‹é£æƒé™
  async function checkMicrophonePermission() {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          sampleRate: 16000,
          channelCount: 1,
          echoCancellation: true,
          noiseSuppression: true
        }
      });
      stream.getTracks().forEach(track => track.stop());
      updateStatus('ready', 'å‡†å¤‡å°±ç»ª');
    } catch (error) {
      showError('æ— æ³•è®¿é—®éº¦å…‹é£ï¼Œè¯·æ£€æŸ¥æµè§ˆå™¨æƒé™è®¾ç½®');
      updateStatus('error', 'éº¦å…‹é£æƒé™è¢«æ‹’ç»');
    }
  }

  // å¼€å§‹å½•éŸ³
  async function startRecording() {
    try {
      hideError();

      // è·å–éŸ³é¢‘æµ
      const stream = await navigator.mediaDevices.getUserMedia({
        audio: {
          channelCount: 1,
          sampleRate: 16000,
          sampleSize: 16,
          echoCancellation: true,
          noiseSuppression: true,
          autoGainControl: false
        }
      });

      // è®¾ç½®éŸ³é¢‘ä¸Šä¸‹æ–‡
      audioContext = new (window.AudioContext || window.webkitAudioContext)({
        sampleRate: 16000
      });

      const source = audioContext.createMediaStreamSource(stream);

      // åˆ›å»ºè„šæœ¬å¤„ç†å™¨æ¥è·å–åŸå§‹PCMæ•°æ®
      audioProcessor = audioContext.createScriptProcessor(4096, 1, 1);

      // é‡ç½®éŸ³é¢‘æ•°æ®
      audioChunks = [];

      // å¤„ç†éŸ³é¢‘æ•°æ®
      audioProcessor.onaudioprocess = (event) => {
        if (!isRecording) return;

        const inputData = event.inputBuffer.getChannelData(0);
        const pcmData = convertFloat32ToInt16(inputData);
        audioChunks.push(pcmData);
      };

      // è¿æ¥éŸ³é¢‘èŠ‚ç‚¹
      source.connect(audioProcessor);
      audioProcessor.connect(audioContext.destination);

      // å¼€å§‹å¤„ç†
      isRecording = true;

      // æ›´æ–°UI
      recordButton.classList.add('recording');
      recordButton.querySelector('.icon').textContent = 'â¹ï¸';
      recordButton.querySelector('.text').textContent = 'åœæ­¢å½•éŸ³';
      updateStatus('recording', 'æ­£åœ¨å½•éŸ³...');

      // å¯åŠ¨è®¡æ—¶å™¨
      startTimer();

      // å¯åŠ¨éŸ³é¢‘å¯è§†åŒ–
      setupAudioVisualization(stream);

      console.log('å¼€å§‹å½•éŸ³ - PCMæ ¼å¼');

    } catch (error) {
      console.error('å¯åŠ¨å½•éŸ³å¤±è´¥:', error);
      showError('å¯åŠ¨å½•éŸ³å¤±è´¥: ' + error.message);
      updateStatus('error', 'å½•éŸ³å¤±è´¥');
    }
  }

  // åœæ­¢å½•éŸ³
  async function stopRecording() {
    if (isRecording) {
      isRecording = false;

      // åœæ­¢éŸ³é¢‘å¤„ç†
      if (audioProcessor) {
        audioProcessor.disconnect();
        audioProcessor = null;
      }

      if (audioContext) {
        await audioContext.close();
        audioContext = null;
      }

      // æ›´æ–°UI
      recordButton.classList.remove('recording');
      recordButton.querySelector('.icon').textContent = 'ğŸ¤';
      recordButton.querySelector('.text').textContent = 'å¼€å§‹å½•éŸ³';
      updateStatus('processing', 'å¤„ç†ä¸­...');

      // åœæ­¢è®¡æ—¶å™¨
      stopTimer();

      // åœæ­¢éŸ³é¢‘å¯è§†åŒ–
      stopAudioVisualization();

      // å¤„ç†å½•åˆ¶çš„éŸ³é¢‘æ•°æ®
      await processRecordedAudio();

      console.log('åœæ­¢å½•éŸ³');
    }
  }

  // å¤„ç†å½•åˆ¶çš„éŸ³é¢‘æ•°æ®
  async function processRecordedAudio() {
    try {
      if (audioChunks.length === 0) {
        throw new Error('æ²¡æœ‰å½•åˆ¶åˆ°éŸ³é¢‘æ•°æ®');
      }

      // åˆå¹¶æ‰€æœ‰PCMæ•°æ®å—
      const totalLength = audioChunks.reduce((sum, chunk) => sum + chunk.length, 0);
      const mergedData = new Int16Array(totalLength);

      let offset = 0;
      for (const chunk of audioChunks) {
        mergedData.set(chunk, offset);
        offset += chunk.length;
      }

      // åˆ›å»ºPCMæ ¼å¼çš„Blob
      const pcmBlob = new Blob([mergedData.buffer], {
        type: 'audio/pcm'
      });

      await sendAudioToServer(pcmBlob, mergedData.length);

    } catch (error) {
      console.error('å¤„ç†éŸ³é¢‘æ•°æ®å¤±è´¥:', error);
      showError('å¤„ç†éŸ³é¢‘å¤±è´¥: ' + error.message);
      updateStatus('error', 'å¤„ç†å¤±è´¥');
      resultContent.classList.add('empty');
      resultContent.textContent = 'å¤„ç†å¤±è´¥ï¼Œè¯·é‡è¯•';
    }
  }

  // å‘é€éŸ³é¢‘åˆ°æœåŠ¡å™¨
  async function sendAudioToServer(audioBlob, dataLength) {
    try {
      updateStatus('processing', 'æ­£åœ¨è½¬å½•...');
      resultContent.classList.add('empty');
      resultContent.innerHTML = '<div class="loading"></div> æ­£åœ¨å¤„ç†éŸ³é¢‘...';

      const formData = new FormData();

      // å…³é”®ä¿®æ”¹ï¼šä½¿ç”¨æ­£ç¡®çš„MIMEç±»å‹å’Œæ–‡ä»¶æ‰©å±•å
      formData.append('file', audioBlob, 'recording.pcm');
      formData.append('userId', document.getElementById('userId').value);
      formData.append('audioEncode', 'pcm_s16le');
      formData.append('sampleRate', '16000');
      formData.append('lang', document.getElementById('language').value);

      // è®¡ç®—éŸ³é¢‘æ—¶é•¿ï¼ˆç§’ï¼‰
      const duration = Math.round(dataLength / 16000);
      formData.append('audioDuration', duration.toString());

      const domain = document.getElementById('domain').value;
      if (domain) {
        formData.append('pd', domain);
      }

      console.log('å‘é€éŸ³é¢‘æ•°æ®:', {
        size: audioBlob.size,
        duration: duration + 'ç§’',
        format: 'PCM',
        sampleRate: '16kHz'
      });

      const response = await fetch('/api/transcription/upload', {
        method: 'POST',
        body: formData
      });

      if (!response.ok) {
        const errorText = await response.text();
        throw new Error(`HTTP ${response.status}: ${errorText}`);
      }

      const result = await response.json();

      if (result.success || result.status === 'SUCCESS') {
        displayResult(result.transcriptionText);
        addToHistory(result);
        updateStatus('ready', 'è½¬å½•å®Œæˆ');
      } else {
        throw new Error(result.message || result.errorMessage || 'è½¬å½•å¤±è´¥');
      }

    } catch (error) {
      console.error('å‘é€éŸ³é¢‘å¤±è´¥:', error);
      showError('è½¬å½•å¤±è´¥: ' + error.message);
      updateStatus('error', 'è½¬å½•å¤±è´¥');
      resultContent.classList.add('empty');
      resultContent.textContent = 'è½¬å½•å¤±è´¥: ' + error.message;
    }
  }

  // å·¥å…·å‡½æ•°ï¼šå°†Float32è½¬æ¢ä¸ºInt16 PCM
  function convertFloat32ToInt16(buffer) {
    const length = buffer.length;
    const pcm = new Int16Array(length);
    for (let i = 0; i < length; i++) {
      const s = Math.max(-1, Math.min(1, buffer[i]));
      pcm[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
    }
    return pcm;
  }

  // æ˜¾ç¤ºè½¬å½•ç»“æœ
  function displayResult(text) {
    resultContent.classList.remove('empty');
    resultContent.textContent = text || '(æ— å†…å®¹)';
  }

  // æ›´æ–°çŠ¶æ€
  function updateStatus(status, text) {
    if (statusIndicator && statusText) {
      statusIndicator.className = `status-indicator ${status}`;
      statusText.textContent = text;
    }
  }

  // è®¡æ—¶å™¨
  function startTimer() {
    startTime = Date.now();
    timerInterval = setInterval(() => {
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const seconds = (elapsed % 60).toString().padStart(2, '0');
      if (timer) {
        timer.textContent = `${minutes}:${seconds}`;
      }
    }, 1000);
  }

  function stopTimer() {
    if (timerInterval) {
      clearInterval(timerInterval);
      timerInterval = null;
    }
  }

  // éŸ³é¢‘å¯è§†åŒ–
  function initAudioVisualizer() {
    if (!audioVisualizer) {
      console.warn('audioVisualizerå…ƒç´ ä¸å­˜åœ¨ï¼Œè·³è¿‡åˆå§‹åŒ–');
      return;
    }

    // æ¸…ç©ºç°æœ‰å†…å®¹
    audioVisualizer.innerHTML = '';

    for (let i = 0; i < 40; i++) {
      const bar = document.createElement('div');
      bar.className = 'audio-bar';
      bar.style.height = '5px';
      audioVisualizer.appendChild(bar);
    }
  }

  function setupAudioVisualization(stream) {
    if (!audioVisualizer) return;

    const vizContext = new (window.AudioContext || window.webkitAudioContext)();
    const vizAnalyser = vizContext.createAnalyser();
    const source = vizContext.createMediaStreamSource(stream);
    source.connect(vizAnalyser);
    vizAnalyser.fftSize = 256;

    const bufferLength = vizAnalyser.frequencyBinCount;
    const dataArray = new Uint8Array(bufferLength);

    audioVisualizer.style.display = 'flex';

    visualizerInterval = setInterval(() => {
      if (!isRecording) return;

      vizAnalyser.getByteFrequencyData(dataArray);
      const bars = audioVisualizer.querySelectorAll('.audio-bar');

      bars.forEach((bar, index) => {
        const value = dataArray[Math.floor(index * bufferLength / bars.length)];
        const height = Math.max(5, (value / 255) * 50);
        bar.style.height = height + 'px';
      });
    }, 50);
  }

  function stopAudioVisualization() {
    if (visualizerInterval) {
      clearInterval(visualizerInterval);
      visualizerInterval = null;
    }
    if (audioVisualizer) {
      audioVisualizer.style.display = 'none';
    }
  }

  // å†å²è®°å½•åŠŸèƒ½
  function addToHistory(result) {
    const history = getHistory();
    const record = {
      sessionId: result.sessionId || Date.now().toString(),
      text: result.transcriptionText,
      status: result.status || (result.success ? 'SUCCESS' : 'FAILED'),
      timestamp: new Date().toISOString(),
      userId: document.getElementById('userId').value
    };
    history.unshift(record);

    if (history.length > 20) {
      history.splice(20);
    }

    localStorage.setItem('transcriptionHistory', JSON.stringify(history));
    renderHistory();
  }

  function getHistory() {
    const history = localStorage.getItem('transcriptionHistory');
    return history ? JSON.parse(history) : [];
  }

  function loadHistory() {
    renderHistory();
  }

  function renderHistory() {
    if (!historyList) return;

    const history = getHistory();

    if (history.length === 0) {
      historyList.innerHTML = '<div style="text-align: center; color: #adb5bd; padding: 20px;">æš‚æ— å†å²è®°å½•</div>';
      return;
    }

    historyList.innerHTML = history.map(record => {
      const date = new Date(record.timestamp);
      const timeStr = date.toLocaleString('zh-CN', {
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit'
      });

      const statusClass = record.status === 'SUCCESS' ? 'completed' :
              record.status === 'PROCESSING' ? 'processing' : 'failed';
      const statusText = record.status === 'SUCCESS' ? 'å·²å®Œæˆ' :
              record.status === 'PROCESSING' ? 'å¤„ç†ä¸­' : 'å¤±è´¥';

      return `
                    <div class="history-item" onclick="showHistoryDetail('${record.sessionId}')">
                        <div class="history-item-header">
                            <span class="history-item-time">${timeStr}</span>
                            <span class="history-item-status ${statusClass}">${statusText}</span>
                        </div>
                        <div class="history-item-text">${record.text || '(æ— å†…å®¹)'}</div>
                    </div>
                `;
    }).join('');
  }

  function showHistoryDetail(sessionId) {
    const history = getHistory();
    const record = history.find(r => r.sessionId === sessionId);
    if (record) {
      displayResult(record.text);
    }
  }

  // é”™è¯¯å¤„ç†
  function showError(message) {
    if (errorMessage) {
      errorMessage.textContent = 'âŒ ' + message;
      errorMessage.classList.add('show');
      setTimeout(() => {
        hideError();
      }, 5000);
    } else {
      console.error('é”™è¯¯æ¶ˆæ¯:', message);
    }
  }

  function hideError() {
    if (errorMessage) {
      errorMessage.classList.remove('show');
    }
  }

  // æ·»åŠ å…¨å±€å‡½æ•°ä¾›å†å²è®°å½•ç‚¹å‡»ä½¿ç”¨
  window.showHistoryDetail = showHistoryDetail;

  // æ·»åŠ å…¨å±€é”™è¯¯æ•è·
  window.addEventListener('error', function(event) {
    console.error('JavaScripté”™è¯¯:', event.message, 'åœ¨:', event.filename, 'ç¬¬', event.lineno, 'è¡Œ');
  });

</script>
</body>
</html>